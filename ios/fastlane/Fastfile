default_platform(:ios)

platform :ios do
  desc "Push a new beta build to TestFlight"
  lane :beta do
    # Try API key first, fall back to Apple ID auth
    api_key = nil

    if ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] && ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] && ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      puts "Using App Store Connect API key authentication"
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        key_content: ENV["APP_STORE_CONNECT_API_KEY_KEY"],
        is_key_content_base64: true,
        in_house: false
      )
    else
      puts "No API key found, using Apple ID authentication"
      puts "You may be prompted for your Apple ID credentials"
    end

    # Get latest build number and increment
    if api_key
      latest_build = latest_testflight_build_number(api_key: api_key)
    else
      latest_build = latest_testflight_build_number
    end
    new_build_number = latest_build + 1

    puts "Latest TestFlight build: #{latest_build}"
    puts "New build number: #{new_build_number}"

    # Increment build number in Xcode project
    increment_build_number(
      build_number: new_build_number,
      xcodeproj: "Runner.xcodeproj"
    )

    # NOTE: Build the IPA manually first with:
    # flutter build ipa --release \
    #   --dart-define=SUPABASE_URL=https://lwyuwxqwshflmuefxgay.supabase.co \
    #   --dart-define=SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx3eXV3eHF3c2hmbG11ZWZ4Z2F5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4MzA5MTgsImV4cCI6MjA4MTQwNjkxOH0.Ias3yQUV8p7D825WwBI08Njry4aQ_OiMkrQRGfwl7zw \
    #   --dart-define=GOOGLE_PLACES_API_KEY=AIzaSyBCkxTR7keDd_gXjXOrj8pptvboMUfg-3Q \
    #   --export-options-plist=ios/ExportOptions.plist

    # Upload to TestFlight
    if api_key
      upload_to_testflight(
        api_key: api_key,
        ipa: "../build/ios/ipa/LumoFit.ipa",
        skip_waiting_for_build_processing: true
      )
    else
      upload_to_testflight(
        ipa: "../build/ios/ipa/LumoFit.ipa",
        skip_waiting_for_build_processing: true
      )
    end

    puts "Successfully uploaded build #{new_build_number} to TestFlight!"
  end

  desc "üöÄ Full auto-deploy: commit, pull, resolve conflicts, build, deploy"
  lane :auto_deploy do
    puts "üöÄ Starting full auto-deploy workflow..."

    # Step 1: Auto-commit changes
    auto_commit_changes

    # Step 2: Pull and auto-resolve conflicts
    auto_pull_and_resolve

    # Step 3: Push to remote
    push_to_git_remote(
      local_branch: "main",
      remote_branch: "main",
      tags: false
    )

    puts "‚úÖ Git sync complete! Now building and deploying..."

    # Step 4: Build and deploy
    beta_with_build
  end

  desc "Build IPA and push to TestFlight"
  lane :beta_with_build do
    # Get latest build number and increment
    latest_build = latest_testflight_build_number
    new_build_number = latest_build + 1

    increment_build_number(
      build_number: new_build_number,
      xcodeproj: "Runner.xcodeproj"
    )

    # Generate changelog from git commits
    changelog = generate_changelog

    # Build Flutter app using direct xcodebuild (bypasses Flutter's CocoaPods check)
    puts "üî® Building Flutter app with Xcode..."

    # Step 1: Flutter build prep (generates Dart code, doesn't require CocoaPods)
    sh("cd ../.. && flutter pub get", log: true)

    # Step 2: Build with xcodebuild directly (pods already installed)
    build_ios_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      output_directory: "../build/ios/ipa",
      output_name: "LumoFit.ipa",
      export_options: "../ExportOptions.plist"
    )

    # Upload to TestFlight with changelog
    upload_to_testflight(
      ipa: "../build/ios/ipa/LumoFit.ipa",
      skip_waiting_for_build_processing: true,
      changelog: changelog
    )

    puts "Successfully uploaded build #{new_build_number} to TestFlight!"
    puts "\nChangelog:\n#{changelog}"
  end

  desc "Generate changelog from git commits since last tag"
  private_lane :generate_changelog do
    # Get commits since last git tag (or last 10 commits if no tag)
    begin
      commits = sh("cd ../.. && git log $(git describe --tags --abbrev=0)..HEAD --pretty=format:'‚Ä¢ %s' --no-merges", log: false).strip
    rescue
      # Fallback to last 10 commits if no tags exist
      commits = sh("cd ../.. && git log -10 --pretty=format:'‚Ä¢ %s' --no-merges", log: false).strip
    end

    if commits.empty?
      changelog = "Bug fixes and performance improvements"
    else
      # Format changelog
      changelog = "What's New:\n#{commits}"

      # Limit to 4000 characters (App Store Connect limit)
      if changelog.length > 4000
        changelog = changelog[0..3996] + "..."
      end
    end

    changelog
  end

  desc "Auto-commit all changes with generated message"
  private_lane :auto_commit_changes do
    # Check if there are changes to commit
    status = sh("cd ../.. && git status --porcelain", log: false).strip

    if status.empty?
      puts "‚úÖ No changes to commit"
      return
    end

    puts "üìù Changes detected, generating commit message..."

    # Get list of changed files
    changed_files = sh("cd ../.. && git status --short", log: false).strip

    # Generate simple commit message based on files
    commit_msg = "chore: Auto-deploy update\n\n#{changed_files}"

    puts "Committing with message:\n#{commit_msg}"

    # Stage all changes
    sh("cd ../.. && git add -A", log: false)

    # Commit
    sh("cd ../.. && git commit -m '#{commit_msg.gsub("'", "\\\\'")}' || true", log: false)

    puts "‚úÖ Changes committed"
  end

  desc "Pull from remote and auto-resolve conflicts"
  private_lane :auto_pull_and_resolve do
    puts "üì• Pulling latest changes from remote main..."

    begin
      # Try to pull
      sh("cd ../.. && git pull origin main", log: false)
      puts "‚úÖ Pull successful, no conflicts"
    rescue => e
      puts "‚ö†Ô∏è  Conflicts detected during pull, attempting auto-resolve..."

      # Get list of conflicted files
      conflicted_files = sh("cd ../.. && git diff --name-only --diff-filter=U", log: false).strip.split("\n")

      if conflicted_files.empty?
        puts "‚úÖ No conflicted files found"
        return
      end

      puts "üîß Auto-resolving conflicts in #{conflicted_files.length} file(s)..."

      # For each conflicted file, keep "ours" (local changes)
      conflicted_files.each do |file|
        puts "  - Resolving #{file} (keeping local changes)"
        sh("cd ../.. && git checkout --ours '#{file}'", log: false)
        sh("cd ../.. && git add '#{file}'", log: false)
      end

      # Commit the merge
      sh("cd ../.. && git commit -m 'chore: Auto-resolve merge conflicts (kept local changes)' --no-edit", log: false)

      puts "‚úÖ Conflicts resolved automatically (kept your local changes)"
    end
  end

  desc "Push a new release build to App Store"
  lane :release do
    # Try API key first, fall back to Apple ID auth
    api_key = nil

    if ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] && ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] && ENV["APP_STORE_CONNECT_API_KEY_KEY"]
      puts "Using App Store Connect API key authentication"
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        key_content: ENV["APP_STORE_CONNECT_API_KEY_KEY"],
        is_key_content_base64: true,
        in_house: false
      )
    else
      puts "No API key found, using Apple ID authentication"
    end

    # Get latest build number and increment
    if api_key
      latest_build = app_store_build_number(api_key: api_key)
    else
      latest_build = app_store_build_number
    end
    new_build_number = latest_build + 1

    # Increment build number in Xcode project
    increment_build_number(
      build_number: new_build_number,
      xcodeproj: "Runner.xcodeproj"
    )

    # Build the Flutter app
    sh "cd ../.. && flutter build ipa --release \
      --dart-define=SUPABASE_URL=https://lwyuwxqwshflmuefxgay.supabase.co \
      --dart-define=SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx3eXV3eHF3c2hmbG11ZWZ4Z2F5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4MzA5MTgsImV4cCI6MjA4MTQwNjkxOH0.Ias3yQUV8p7D825WwBI08Njry4aQ_OiMkrQRGfwl7zw \
      --dart-define=GOOGLE_PLACES_API_KEY=AIzaSyBCkxTR7keDd_gXjXOrj8pptvboMUfg-3Q \
      --export-options-plist=ios/ExportOptions.plist"

    # Upload to App Store
    if api_key
      upload_to_app_store(
        api_key: api_key,
        ipa: "../build/ios/ipa/LumoFit.ipa",
        skip_screenshots: true,
        skip_metadata: true,
        precheck_include_in_app_purchases: false
      )
    else
      upload_to_app_store(
        ipa: "../build/ios/ipa/LumoFit.ipa",
        skip_screenshots: true,
        skip_metadata: true,
        precheck_include_in_app_purchases: false
      )
    end

    puts "Successfully uploaded build #{new_build_number} to App Store!"
  end
end
